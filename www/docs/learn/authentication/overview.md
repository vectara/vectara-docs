---
id: auth-overview
title: Authentication Methods and Authorization Levels
sidebar_label: Authentication Methods and Authorization Levels
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Config} from '@site/docs/definitions.md';
import vars from '@site/static/variables.json';

Vectara has robust authentication and authorization methods in place to secure 
your data and operations, whether you are an Admin configuring the 
system or tenant, a Developor building applications for your enterprise, 
or an End User issuing queries through an application. We provide a 
structured authentication and authorization model to control access to our 
platform and your data. 

This overview introduces the supported mechanisms and access control levels, 
helps you understand what is platform-enforced versus application-enforced, 
and provides a quick reference to help answer key questions for 
internal discussions--useful for Dev Team Leads planning integrations or 
Business Leaders evaluating security.

## Authentication methods in Vectara

Vectara supports two authentication strategies:

- **API Keys** ‚Äì Lightweight tokens for direct API access, often used for quick 
  prototyping or front-end queries.
- **OAuth 2.0 Tokens** ‚Äì Expiring JWT tokens generated by app clients, suited for 
  secure production environments.

Use the following table to understand the key types, whether you develop 
applications and test APIs, or a Platform Admin configuring systems or managing 
corpora.


| API Key Type       | Key Prefix | Allowed Operations                                                 | Access Scope                            | Intended Use                                              |
|--------------------|------------|--------------------------------------------------------------------|------------------------------------------|------------------------------------------------------------|
| **Personal API Key**  | `zut_...`  | All operations, with some limitations such as not deleting your account or creating users | Account-wide (inherits user‚Äôs permissions) | Administrative tasks, prototyping, full access across corpora |
| **Query API Key**      | `zqt_...`  | Read-only search operations                                        | Corpus-specific                          | Front-end applications, public-facing query requests       |
| **Index API Key**      | `zwt_...`  | Read and write (indexing and querying)                             | Corpus-specific                          | Server-side indexing and querying                          |
| **OAuth 2.0 Token**    | (JWT token)| Scoped by roles granted to OAuth client                           | Account or corpus scope                  | Secure production authentication, third-party integrations |


:::tip Need help choosing?
See [**Choosing the Right Authentication Method**](/docs/learn/authentication/choose-auth-method) to decide whether 
to use API keys or OAuth based on your use case.
:::

## Authorization levels in Vectara

Vectara primarily enforces authorization at the **account** and **corpus** level 
through [Role-Based Access Control (RBAC)](/docs/learn/authentication/role-based-access-control), critical for 
Admins managing users on the Vectara Platform, or Developers scoping corpus access. You can 
layer [Attribute-Based Access Control (ABAC)](/docs/learn/authentication/attribute-based-access-control) by applying metadata-based filters
at query time. Let's explore the five authorization levels‚Äî**account administration**, 
**corpus access**, **coarse-grained** (document-level), **fine-grained** 
(part-level), and **multi-tenancy**‚Äîto help you implement secure access control.

### Account administration roles

- **What It Controls**: High-level admin and management actions across all corpora, 
  such as user management, account settings, and corpus creation.
- **How It Works**: Vectara assigns account-level roles (Owner, Account Admin, 
  Billing Admin) to grant full administrative access. Owners have unrestricted 
  control, including account deletion, while Account Admins manage corpora and 
  users (excluding billing). Billing Admins focus solely on billing tasks. 
  These roles do not allow direct access to document contents.
- **Supported Mechanisms**: RBAC with predefined roles, managed by Admins 
  through the Console.
- **Use Case**: A platform Admin assigns an Account Admin role to a team member 
  to oversee all corpora without touching billing data.
- **Limitations**: Fully supported with no restrictions, but roles do not provide 
  granular document access‚Äîuse corpus-level roles for data-specific tasks.
- **Key Question Answered**: *How do I define administrators?* Assign Owner or 
  Account Admin roles in the Console for broad control, ensuring only trusted 
  Admins get these privileges.

### Corpus access management

- **What It Controls**: Determines which users, API keys, or apps can query, index, 
  or administer a specific corpus. This is essential for Developers scoping 
  access.
- **How It Works**: Corpus-level roles‚ÄîQuery (QRY) for read-only searches, Index (IDX) 
  for write and query, and Admin (ADM) for full control‚Äîare assigned per corpus. 
  API keys (`zqt_`, `zwt_`) or OAuth tokens are scoped to individual corpora, 
  preventing cross-corpus access unless explicitly granted. Admins manage these 
  roles with the Console.
- **Supported Mechanisms**: Role-based access control with QRY, IDX, and ADM roles, 
- configurable by   Admins.
- **Use Case**: A Dev Team Lead assigns a Query role to an App Developer‚Äôs API 
  key for read-only access to a marketing corpus.
- **Limitations**: Fully supported and the primary method for data segmentation. 
  This is ideal for secure, isolated access.
- **Key Question Answered**: *How do I limit access to corpora?* Use QRY, IDX, or 
  ADM roles per corpus, scoping keys or tokens to specific corpora via the Console.

### Coarse-grained (document-level) access control

- **What It Controls**: Ensures users see only their authorized documents within 
  a shared corpus, a common need for Application End Users like Mary accessing 
  personal data.
- **How It Works**: Since Vectara lacks native document-level ACLs, you apply 
  metadata filters at query time (`metadata_filter: "user_id = X"`) to simulate 
  isolation. Client Apps, coded by App Developers, enforce these filters to 
  restrict visibility based on metadata like `owner` or `groups`.
- **Supported Mechanisms**: Attribute-based access control with metadata filters, 
  implemented at the application level.
- **Use Case**: An App Developer configures a Client App to filter HR documents 
  so only Mary sees her records (`user_id = mary`).
- **Limitations**: Not platform-enforced. It relies on application logic. Users with 
  Query access could bypass filters if misused, requiring careful Client App design.
- **Key Question Answered**: *How do I restrict document access?* Use Attribute-based 
  access control filters in your app‚Äôs query logic, ensuring metadata like `user_id` 
  is set during indexing.

### Fine-grained (part-level) access control

- **What It Controls**: Limits visibility to specific parts (chunks) of a document, a 
  granular need for sensitive data‚Äîoften a concern for App Developers securing 
  Client Apps.
- **How It Works**: Vectara does not natively support part-level ACLs. Instead, 
  you store sensitive parts in a separate, restricted corpus or use metadata 
  filters to obscure them during queries. Anyone with Query (QRY) access to a 
  corpus sees the entire document, so workarounds are critical.
- **Supported Mechanisms**: Attribute-based access control with metadata filters 
  or corpus segmentation, enforced by the application.
- **Use Case**: A Developer indexes sensitive fields (salary data) in a restricted 
  corpus, accessible only to authorized Client Apps with specific keys.
- **Limitations**: Not natively supported. It requires careful corpus design or 
  filter logic. Workarounds add complexity for App Developers.
- **Key Question Answered**: *How do I control specific document parts?* Segregate 
  sensitive parts into a restricted corpus or apply strict metadata filters in your app.

### Multi-tenancy

- **What It Controls**: Enforces isolation for different customers or teams, ensuring 
  each tenant, like an Application End User group, accesses only their data. 
  This is a priority for Admins managing enterprise deployments.
- **How It Works**: Assign each tenant a dedicated corpus with its own API keys or 
  OAuth tokens, managed with the Console. This platform-enforced isolation prevents 
  cross-tenant access. Alternatively, use app-enforced filters (ABAC) within a 
  shared corpus, but they may be less secure.
- **Supported Mechanisms**: Corpus-level RBAC for isolation, with optional ABAC 
  filters for shared corpora.
- **Use Case**: An Admin creates a corpus (`tenant_acme_docs`) for Acme Inc., 
  granting scoped keys to their Client App, ensuring no access to data from 
  other tenants.
- **Limitations**: Corpus management adds overhead, but it provides the most secure 
  approach. Filter-based alternatives may risk exposure if misconfigured.
- **Key Question Answered**: *How do I isolate tenant data?* Dedicate a corpus per 
  tenant with scoped keys, configured by Admins in the Console for robust security.

## Next steps

Use the following task guides to implement secure access and authorization:

- üîë [Create and Use API Keys](/docs/learn/authentication/api-key-management)
- üîê [Use OAuth 2.0](/docs/learn/authentication/oauth-2)
- üë• [Assign Roles to Users and Clients (RBAC)](/docs/learn/authentication/role-based-access-control)
- üéØ [Apply Metadata Filters for Attribute-Based Access Control (ABAC)](/docs/learn/authentication/attribute-based-access-control)
- üè¢ [Isolate Tenants with Corpora](/docs/learn/authentication/multi-tenant-corpus-isolation)
- üß† [Combine ABAC with Application-Specific Filters](/docs/learn/authentication/combine-access-control-with-app-filters)

